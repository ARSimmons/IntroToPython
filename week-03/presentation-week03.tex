\documentclass{beamer}
%\usepackage[latin1]{inputenc}
\usetheme{Warsaw}
\title[Intro to Python: Week 3]{Introduction  to Python\\ Topics}
\author{Christopher Barker}
\institute{UW Continuing Education}
\date{October 15, 2013}

\usepackage{listings}
\usepackage{hyperref}

\begin{document}

% ---------------------------------------------
\begin{frame}
  \titlepage
\end{frame}

% ---------------------------------------------
\begin{frame}
\frametitle{Table of Contents}
%\tableofcontents[currentsection]
  \tableofcontents
\end{frame}


\section{Review/Questions}

% ---------------------------------------------
\begin{frame}{Review of Previous Class}

\begin{itemize}
  \item Recusive functions
  \item Truthiness
  \item Modules and name spaces
\end{itemize}

\end{frame}


% ---------------------------------------------
\begin{frame}{Lightning Talks}

\vfill
{\LARGE Lightning talks today:}

\vfill
{\Large
Nate Flagg

\vfill
Duane Wright

\vfill
Jo-Anne Antoun 

\vfill
Josh Rakita

}
\vfill

\end{frame}


% ---------------------------------------------
\begin{frame}{Homework review}

  \vfill
  {\Large Homework Questions? }

  \vfill
  {\Large My Solution}

  \vfill

\end{frame}

% ************************************
\section {Sequences}

\begin{frame}[fragile]{Sequences}

{\Large Sequences are ordered collections of objects}

\vfill
{\Large They can be indexed, sliced, iterated over,...}

\vfill
{\Large They have a length:  \verb+len(sequence)+}

\vfill
{\Large Common sequences (Remember Duck Typing?):}

{\Large
\begin{itemize}
   \item strings
   \item tuples
   \item lists
\end{itemize}
}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Indexing}

{\Large square brackets for indexing: \verb+[]+}

\vfill
{\Large Indexing starts at zero}

\begin{verbatim}
In [98]: s = "this is a string"

In [99]: s[0]
Out[99]: 't'

In [100]: s[5]
Out[100]: 'i'
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Indexing}

{\Large Negative indexes count from the end}

\vfill
\begin{verbatim}
In [105]: s = "this is a string"

In [106]: s[-1]
Out[106]: 'g'

In [107]: s[-6]
Out[107]: 's'
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Slices}

{\Large Slicing: Pulling a range out of a sequence}

\begin{verbatim}
sequence[start:finish]  

indexes for which:

start <= i < finish
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Slices}
\begin{verbatim}
In [121]: s = "a bunch of words"
In [122]: s[2]
Out[122]: 'b'

In [123]: s[6]
Out[123]: 'h'

In [124]: s[2:6]
Out[124]: 'bunc'

In [125]: s[2:7]
Out[125]: 'bunch'
\end{verbatim}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{Slices}

{\Large the indexes point to the spaces between the items}

\vfill
\begin{verbatim}
   X   X   X   X   X   X   X   X
 |   |   |   |   |   |   |   | 
 0   1   2   3   4   5   6   7
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Slices}

{\Large Slicing satisfies nifty properties:

\vfill
\begin{verbatim}
len( seq[a:b] ) == b - a

seq[a:b] + seq[b:c] == seq

\end{verbatim}

}

\end{frame}

% ------------------------------------------------
\begin{frame}[fragile]{Slicing vs. Indexing}

{\Large Indexing returns a single element}

\begin{verbatim}
In [86]: l
Out[86]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [87]: type(l)
Out[87]: list

In [88]: l[3]
Out[88]: 3

In [89]: type( l[3] )
Out[89]: int
\end{verbatim}
\end{frame}

% ------------------------------------------------
\begin{frame}[fragile]{Slicing vs. Indexing}

{\Large Unless it's a string:}

\begin{verbatim}
In [75]: s = "a string"

In [76]: s[3]
Out[76]: 't'

In [77]: type(s[3])
Out[77]: str
\end{verbatim}

\vfill
There is no single character type

\end{frame}


%-------------------------------
\begin{frame}[fragile]{Slicing vs. Indexing}

{\Large Slicing returns a sequence:}

\begin{verbatim}
In [68]: l
Out[68]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [69]: l[2:4]
Out[69]: [2, 3]
\end{verbatim}

Even if it's one element long

\begin{verbatim}
In [70]: l[2:3]
Out[70]: [2]

In [71]: type(l[2:3])
Out[71]: list
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Slicing vs. Indexing}

{\Large Indexing out of range produces an error}
\vfill
\begin{verbatim}
In [129]: s = "a bunch of words"
In [130]: s[17]
----> 1 s[17]
IndexError: string index out of range
\end{verbatim}

\vfill
{\Large Slicing just gives you what's there}

\begin{verbatim}
In [131]: s[10:20]
Out[131]: ' words'

In [132]: s[20:30]
Out[132]: ''
\end{verbatim}
(demo)
\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{Multiplying and slicing}

{\Large from CodingBat: Warmup-1 -- front3}

\begin{verbatim}
def front3(str):
  if len(str) < 3:
    return str+str+str
  else:
    return str[:3]+str[:3]+str[:3]
\end{verbatim}

{\Large or}

\begin{verbatim}
def front3(str):
    return str[:3] * 3
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Slicing}

{\Large from CodingBat: Warmup-1 -- \verb+missing_char+ }

\begin{verbatim}
def missing_char(str, n):
  front = str[0:n]
  l = len(str)-1
  back = str[n+1:l+1]
  return front + back
\end{verbatim}

\begin{verbatim}
def missing_char(str, n):
    return str[:n] + str[n+1:]
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Slicing}

{\Large you can skip items, too}

\begin{verbatim}
In [289]: string = "a fairly long string"

In [290]: string[0:15]
Out[290]: 'a fairly long s'

In [291]: string[0:15:2]
Out[291]: 'afil ogs'

In [292]: string[0:15:3]
Out[292]: 'aallg'
\end{verbatim}

\end{frame} 

% ---------------------------------------
\begin{frame}[fragile]{Command Line Input}

{\Large \verb|input| evaluates the input:}
\begin{verbatim}
In [265]: val = input("a message> ")
a message> 4.5
In [266]: type(val)
Out[266]: float
\end{verbatim}

{\Large \verb|raw_input| gives you the plain string:}
\begin{verbatim}
In [265]: val = input("a message> ")
a message> 4.5
In [266]: type(val)
Out[266]: float
\end{verbatim}

\vfill
(demo)
\end{frame}


%-------------------------------
\begin{frame}[fragile]{LAB}

\verb| def count_them(letter): |
\begin{itemize}
  \item prompts the user to input a letter
  \item counts the number of times the given letter is input
  \item prompts the user for another letter
  \item continues until the user inputs "x"
  \item returns the count of the letter input
\end{itemize}

\verb| def count_letter_in_string(string, letter): |
\begin{itemize}
  \item counts the number of instances of the letter in the string
  \item ends when a period is encountered
  \item if no period is encountered -- prints "hey, there was no period!"
\end{itemize}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{LAB}
Write some functions that:
\begin{itemize}
  \item return a string with the first and last characters exchanged.
  \item return a string with every other character removed
  \item return a string with the first and last 4 characters removed, and every other char in between
  \item return a string reversed (just with slicing)
  \item return a string with the middle, then last, then first third in a new order
\end{itemize}

\end{frame}

%-------------------------------
\begin{frame}{Lightning Talk}

{\LARGE Lightning Talks:}

\vfill
{\large Nate Flag}

\vfill
{\large Duane Wright}

\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Lists, Tuples...}

% ---------------------------------------------
\begin{frame}[fragile]{Lists}

 {\Large List Literals}

\begin{verbatim}
>>> []
[]
>>> list()
[]
>>> [1, 2, 3]
[1, 2, 3]
>>> [1, 3.14, "abc"]
[1, 3.14, 'abc']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Lists}

 {\Large List ``type''}

 {\large \hspace{0.1in}(also constructor)}

\begin{verbatim}
>>> type(list)
<type 'type'>
>>> list( (1,2,3) )
[1, 2, 3]
>>> list( "a string" )
\end{verbatim}

\vfill
{\Large Takes any sequence, tries to turn it into a list}

\vfill
{\large like \verb|int()|, \verb|float()|, etc.}


\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{List Indexing}

 {\Large Indexing just like all sequences}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food[2]
'ham'
>>> food[0]
'spam'
>>> food[42]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Mutability}

{\Large Lists are mutable}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food[1] = 'raspberries'
>>> food
['spam', 'raspberries', 'ham']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Elements}

{\Large Each element is a value, and can be in multiple lists and have multiple
names (or no name)}

\begin{verbatim}
  >>> name = 'Brian'
   >>> a = [1, 2, name]
   >>> b = [3, 4, name]
   >>> name
   'Brian'
   >>> a
   [1, 2, 'Brian']
   >>> b
   [3, 4, 'Brian']
   >>> a[2]
   'Brian'
   >>> b[2]
   'Brian'
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Methods}

{\Large \verb| .append(), .insert()|}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food.append('sushi')
>>> food
['spam', 'eggs', 'ham', 'sushi']
>>> food.insert(0, 'carrots')
>>> food
['carrots', 'spam', 'eggs', 'ham', 'sushi']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Methods}

{\large \verb| .extend()|}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food.extend(['fish', 'chips'])
>>> food
['spam', 'eggs', 'ham', 'fish', 'chips']
\end{verbatim}

{\large could be any sequence:}

\begin{verbatim}
>>>  food
>>>  ['spam', 'eggs', 'ham']
>>>  silverware = ('fork', 'knife', 'spoon') # a tuple
>>>  food.extend(silverware)
>>>  food
>>>  ['spam', 'eggs', 'ham', 'fork', 'knife', 'spoon']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Methods}

{\large \verb|pop(), remove() |}

\begin{verbatim}
In [203]: food = ['spam', 'eggs', 'ham', 'toast']
In [204]: food.pop()
Out[204]: 'toast'
In [205]: food.pop(0)
Out[205]: 'spam'
In [206]: food
Out[206]: ['eggs', 'ham']
In [207]: food.remove('ham')
In [208]: food
Out[208]: ['eggs']
\end{verbatim}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Constructor}

{\large \verb|list()| accepts any sequence and returns a list of that sequence}
\begin{verbatim}
>>> word = 'Python '
>>> chars = []
>>> for char in word:
...   chars.append(char)
>>> chars
['P', 'y', 't', 'h', 'o', 'n', ' ']
>>> list(word)
['P', 'y', 't', 'h', 'o', 'n', ' ']
\end{verbatim}
\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{String to List to String}

{\large If you need to change individual letters... you can do this,
but usually \verb|somestring.replace()| will be enough }

\begin{verbatim}
In [216]: name = 'Chris'
In [217]: lname = list(name)
In [218]: lname[0:2] = 'K'
In [219]: name = ''.join(lname)
In [220]: name
Out[220]: 'Kris'
\end{verbatim}

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{Building up strings in a list}

\begin{verbatim}
In [221]: msg = []

In [222]: msg.append('The first line of a message')

In [223]: msg.append('The second line of a message')

In [224]: msg.append('And one more line')

In [225]: print '\n'.join(msg)
The first line of a message
The second line of a message
And one more line
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Slicing}

{\large Slicing makes a copy}

\begin{verbatim}
In [227]: food = ['spam', 'eggs', 'ham', 'sushi']

In [228]: some_food = food[1:3]

In [229]: some_food[1] = 'bacon'

In [230]: food
Out[230]: ['spam', 'eggs', 'ham', 'sushi']

In [231]: some_food
Out[231]: ['eggs', 'bacon']
\end{verbatim}

\end{frame}


% ---------------------------------------------
\begin{frame}[fragile]{List Slicing}

{\large Easy way to copy a whole list}

\begin{verbatim}
In [232]: food
Out[232]: ['spam', 'eggs', 'ham', 'sushi']

In [233]: food2 = food[:]

In [234]: food is food2
Out[234]: False

\end{verbatim}

{\Large but the copy is ``shallow''}: \
\url{http://docs.python.org/library/copy.html}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Slicing}

{\Large ``Shallow'' copy}

\begin{verbatim}
In [249]: food = ['spam', ['eggs', 'ham']]
In [251]: food_copy = food[:]
In [252]: food[1].pop()
Out[252]: 'ham'
In [253]: food
Out[253]: ['spam', ['eggs']]
In [256]: food.pop(0)
Out[256]: 'spam'
In [257]: food
Out[257]: [['eggs']]
In [258]: food_copy
Out[258]: ['spam', ['eggs']]
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Name Binding}

{\Large Assigning to a name does not copy:}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> food_again = food
>>> food_copy = food[:]
>>> food.remove('sushi')
>>> food
['spam', 'eggs', 'ham']
>>> food_again
['spam', 'eggs', 'ham']
>>> food_copy
['spam', 'eggs', 'ham', 'sushi']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Iterating}

{\Large Iterating over a list}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> for x in food:
...   print x
...
spam
eggs
ham
sushi
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Processing Lists}

{\Large A common pattern}

\begin{verbatim}
filtered = []
for x in somelist:
    if should_be_included(x):
        filtered.append(x)
del(somelist)  # maybe
\end{verbatim}

{\Large you don't want to be deleting items from the list while iterating...}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Mutating Lists}

{\Large if you're going to change the list, iterate over a copy for safety }

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> for x in food[:]:
   ...   # change the list somehow
   ...
\end{verbatim}

{\Large insidious bugs otherwise}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{operators vs methods}

{\large What's the difference?}

\begin{verbatim}
   >>> food = ['spam', 'eggs', 'ham']
   >>> more = ['fish', 'chips']
   >>> food = food + more
   >>> food
   ['spam', 'eggs', 'ham', 'fish', 'chips']

   >>> food = ['spam', 'eggs', 'ham']
   >>> more = ['fish', 'chips']
   >>> food.extend(more)
   >>> food
   ['spam', 'eggs', 'ham', 'fish', 'chips']
\end{verbatim}
(the operator makes a new list...)

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{in}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> 'eggs' in food
True
>>> 'chicken feet' in food
False
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{reverse()}


\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food.reverse()
>>> food
['ham', 'eggs', 'spam']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{sort()}

\vfill
\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> food.sort()
>>> food
['eggs', 'ham', 'spam', 'sushi']
\end{verbatim}

\vfill
{\Large note:}

\vfill
\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> result = food.sort()
>>> print result
None
\end{verbatim}

\vfill
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Sorting}

{\large How should this sort?}

\begin{verbatim}
>>> s
[[2, 'a'], [1, 'b'], [1, 'c'], [1, 'a'], [2, 'c']]
\end{verbatim}

\pause

\begin{verbatim}
>>> s.sort()
>>> s
[[1, 'a'], [1, 'b'], [1, 'c'], [2, 'a'], [2, 'c']]
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Sorting}

{\large You can specify your own compare function:}

\begin{verbatim}
In [279]: s = [[2, 'a'], [1, 'b'], [1, 'c'], [1, 'a'], [2, 'c']]
In [281]: def comp(s1,s2):
   .....:     if s1[1] > s2[1]: return 1
   .....:     elif s1[1]<s2[1]: return -1
   .....:     else:
   .....:         if s1[0] > s2[0]: return 1
   .....:         elif s1[0] < s2[0]: return -1
   .....:     return 0
In [282]: s.sort(comp)
In [283]: s
Out[283]: [[1, 'a'], [2, 'a'], [1, 'b'], [1, 'c'], [2, 'c']]
\end{verbatim}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Sorting}

{\Large
Mixed types can be sorted.
}
\vfill
{\center \Large

``objects of different types always compare unequal, and are ordered
consistently but arbitrarily.''

}

\vfill
\url{http://docs.python.org/reference/expressions.html#not-in}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Searching}

{\Large Finding or Counting items}

\begin{verbatim}
In [288]: l = [3,1,7,5,4,3]

In [289]: l.index(5)
Out[289]: 3

In [290]: l.count(3)
Out[290]: 2
\end{verbatim}

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{List Performance }

\begin{itemize}
  \item indexing is fast and constant time: O(1)
  \item x in s proportional to n: O(n)
  \item visiting all is proportional to n: O(n)
  \item operating on the end of list is fast and constant time: O(1) \\
     append(), pop()
  \item operating on the front (or middle) of the list depends on n: O(n)\\
     pop(0), insert(0, v) \\
     But, reversing is fast. Also, collections.deque
\end{itemize}

\url{ http://wiki.python.org/moin/TimeComplexity}

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{Lists vs. Tuples}

\vfill
{\Large List or Tuples}

\vfill
{\Large
If it needs to mutable: list

\vfill
If it needs to be immutable: tuple\\
}
\hspace{0.2in}{\large (dict key, safety when passing to a function) }

\vfill
{\Large Otherwise ... taste and convention}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List vs Tuple}

\vfill
{\LARGE Convention:}

\vfill
{\Large Lists are Collections (homogeneous):\\[0.1in]
-- contain values of the same type \\ 
-- simplifies iterating, sorting, etc
}

\vfill
{\Large tuples are mixed types:\\[0.1in]
-- Group multiple values into one logical thing
-- Kind of like simple C structs.
}
\vfill

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List vs Tuple}

{\Large
\begin{itemize}
  \item Do the same operation to each element?
  \item Small collection of values which make a single logical item?
  \item To document that these values won't change?
  \item Build it iteratively?
  \item Transform, filter, etc?
\end{itemize}
}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List vs Tuple}

{\Large
\begin{itemize}
  \item Do the same operation to each element? {\bf list}
  \item Small collection of values which make a single logical item? {\bf tuple}
  \item To document that these values won't change? {\bf tuple}
  \item Build it iteratively? {\bf list}
  \item Transform, filter, etc? {\bf list}
\end{itemize}
}

\end{frame} 

\begin{frame}[fragile]{List Docs}

\vfill
{\Large The list docs:}

\vfill
\url{http://docs.python.org/library/stdtypes.html#mutable-sequence-types}

\vfill
(actually any mutable sequence....)

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{tuples and commas..}

{\Large  Tuples don't NEED parentheses... }

\begin{verbatim}
In [161]: t = (1,2,3)
In [162]: t
Out[162]: (1, 2, 3)

In [163]: t = 1,2,3
In [164]: t
Out[164]: (1, 2, 3)

In [165]: type(t)
Out[165]: tuple
\end{verbatim}

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{tuples and commas..}

{\Large  Tuples do need commas... }

\begin{verbatim}
In [156]: t = ( 3 )

In [157]: type(t)
Out[157]: int

In [158]: t = (3,)
In [159]: t
Out[159]: (3,)

In [160]: type(t)
Out[160]: tuple
\end{verbatim}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{LAB}

\vfill
{\LARGE List Lab}

\vfill
\verb|week-03/code/list_lab.rst|

\vfill

\end{frame}

%-------------------------------
\begin{frame}{Lightning Talk}

{\LARGE Lightning Talks:}

\vfill
{\large Jo-Anne Antoun}

\vfill
{\large Josh Rakita}

\end{frame}



\section{Looping}

%-------------------------------
\begin{frame}[fragile]{for loops}

{\Large looping through sequences

\begin{verbatim}
for x in sequence:
    do_something_with_x
\end{verbatim}
}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{for loops}

\begin{verbatim}
In [170]: for x in "a string":
   .....:         print x
   .....:     
a
 
s
t
r
i
n
g
\end{verbatim}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{range}

{\Large looping a known number of times..}

\begin{verbatim}
In [171]: for i in range(5):
   .....:     print i
   .....:     
0
1
2
3
4
\end{verbatim}
(you don't need to do anything with i...
\end{frame}

%-------------------------------
\begin{frame}[fragile]{range}

{\Large \verb|range| defined similarly to indexing}

\begin{verbatim}
In [183]: range(4)
Out[183]: [0, 1, 2, 3]

In [184]: range(2,4)
Out[184]: [2, 3]

In [185]: range(2,10,2)
Out[185]: [2, 4, 6, 8]
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{indexing?}

{\Large Python only loops through a sequence -- not like C, Javascript, etc...}
\begin{verbatim}
for(var i=0; i<arr.length; i++) {
    var value = arr[i];
    alert(i =") "+value);
}
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{indexing?}

{\Large Use range?}
\begin{verbatim}
In [193]: letters = "Python"

In [194]: for i in range(len(letters)):
   .....:     print letters[i]
   .....:     
P
y
t
h
o
n
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{indexing?}

{\Large More Pythonic -- for loops through sequences}
\begin{verbatim}
In [196]: for l in letters:
   .....:     print l
   .....:     
P
y
t
h
o
n
\end{verbatim}
\vfill
{\large Never index in normal cases}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{enumerate}

{\Large If you need an index -- \verb|enumerate|}
\begin{verbatim}
In [197]: for i, l in enumerate(letters):
   .....:     print i, l
   .....:     
0 P
1 y
2 t
3 h
4 o
5 n
\end{verbatim}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{multiple sequences -- zip}

{\Large If you need to loop though parallel sequences -- \verb|zip|}
\begin{verbatim}
In [200]: first_names = ['Fred', 'Mary', 'Jane']

In [201]: last_names = ['Baker', 'Jones', 'Miller']

In [203]: for first, last in zip(first_names, last_names):
   .....:     print first, last
   .....:     
Fred Baker
Mary Jones
Jane Miller
\end{verbatim}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{xrange}

{\Large \verb|range| creates the whole list}

\vfill
{\Large \verb|xrange| is a generator -- creates it as it's needed --}

\vfill
{\Large a good idea for large numbers}

\begin{verbatim}
In [207]: for i in xrange(3):
   .....:     print i
0
1
2
\end{verbatim}
(Python 3 -- \verb|range == xrange|)
\end{frame}



%-------------------------------
\begin{frame}[fragile]{for}

{\Large \verb|for| does NOT create a name space:}

\begin{verbatim}
In [172]: x = 10

In [173]: for x in range(3):
   .....:     pass
   .....: 

In [174]: x
Out[174]: 2
\end{verbatim}
\end{frame}



%-------------------------------
\begin{frame}[fragile]{while}

{\Large \verb|while| is for when you don't know how many loops you need}

\vfill
{\Large Continues to execute the body until condition is not \verb|True|}

\begin{verbatim}
while a_condition:
   some_code
   in_the_body
\end{verbatim}
\end{frame}



%-------------------------------
\begin{frame}[fragile]{while}

{\Large \verb|while| is more general than \verb|for| -- 
you can always express for as while,
but not always vice-versa.}

\vfill

{\Large \verb|while| is more error-prone -- requires some care to terminate}

\vfill
{\Large  loop body must make progress, so condition can become \verb|False| }

\vfill
{\Large  potential error: infinite loops }
\end{frame}



%-------------------------------
\begin{frame}[fragile]{while vs. for}

\begin{verbatim}
letters = 'Python'
i=0
while i < len(letters):
    print letters[i]
    i += 1
\end{verbatim}
vs.
\begin{verbatim}
letters = 'Python'
for c in letters:
    print c
\end{verbatim}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{while}

{\Large Shortcut: recall -- 0 or empty sequence is \verb|False| }

%\begin{verbatim}
%while x:    # terminates if x >= 0 on entry
%    ...     # do something with x
%    x -= 1  # make progress toward 0
%\end{verbatim}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{break}

{\Large \verb|break| ends a loop early}

\begin{verbatim}
x = 0
while True:
    print x
    if x > 3:
        break
    x = x + 1
In [216]: run for_while.py
0
1
2
3
4
\end{verbatim}

This is a pretty common idiom

\end{frame}

%-------------------------------
\begin{frame}[fragile]{break}

{\Large same way with a \verb|for| loop }

\begin{verbatim}
name = "Chris Barker"
for c in name:
    print c,
    if c == "B":
        break
print "I'm done"

C h r i s   B 
I'm done
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{continue}

{\Large \verb|continue| skips to the start of the loop again}

\begin{verbatim}
print "continue in a for loop"
name = "Chris Barker"
for c in name:
    if c == "B":
        continue
    print c,
print "\nI'm done"

continue in a for loop
C h r i s   a r k e r 
I'm done
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{continue}

{\Large \verb|continue| works for a \verb|while| loop too.}

\begin{verbatim}
print "continue in a while loop"
x = 6
while x > 0:
    x = x-1
    if x%2:
        continue
    print x,
print "\nI'm done"

continue in a while loop
4 2 0 
I'm done
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{else again}

{\Large \verb|else| block run if the loop finished naturally -- no \verb|break|}

\begin{verbatim}
print "else in a for loop"
x = 5
for i in range(5):
    print i
    if i == x:
        break
else:
    print "else block run"

\end{verbatim}
\end{frame}


% ##################################
\section{Dictionaries and Sets}

% ---------------------------------------------
\begin{frame}[fragile]{Dictionary}

{\Large Python calls it a \verb|dict| }

\vfill
{\Large Other languages call it:}
\begin{itemize}
  \item dictionary
  \item associative array
  \item map
  \item hash table
  \item hash
  \item key-value pair
\end{itemize}

\vfill

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Dictionary Constructors}

\begin{verbatim}
>>> {'key1': 3, 'key2': 5}
{'key1': 3, 'key2': 5}

>>> dict([('key1', 3),('key2', 5)])
{'key1': 3, 'key2': 5}

>>> dict(key1=3, key2= 5)
{'key1': 3, 'key2': 5}

>>> d = {}
>>> d['key1'] = 3
>>> d['key2'] = 5
>>> d
{'key1': 3, 'key2': 5}
\end{verbatim}
% {\Large Which to use depends on the shape of your data}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Dictionary Indexing}

\begin{verbatim}
>>> d = {'name': 'Brian', 'score': 42}
>>> d['score']
42
>>> d = {1: 'one', 0: 'zero'}
>>> d[0]
'zero'
>>> d['non-existing key']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'non-existing key'
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Dictionary Indexing}

{\Large Keys can be any immutable:}
\begin{itemize}
  \item numbers
  \item string
  \item tuples
\end{itemize}

\begin{verbatim}
In [325]: d[3] = 'string'
In [326]: d[3.14] = 'pi'
In [327]: d['pi'] = 3.14
In [328]: d[ (1,2,3) ] = 'a tuple key'
In [329]: d[ [1,2,3] ] = 'a list key'
   TypeError: unhashable type: 'list'
\end{verbatim}

\vfill
Actually -- any "hashable" type.
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Dictionary Indexing}

\vfill
{\Large hash functions convert arbitrarily large data to a small proxy (usually int)

\vfill
always return the same proxy for the same input

\vfill
MD5, SHA, etc
\vfill
}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Dictionary Indexing}

\vfill
{\Large
Dictionaries hash the key to an integer proxy and use it to find the key and value
}
\vfill
{\Large
Key lookup is efficient because the hash function leads directly to a bucket with a very few keys (often just one)
}
\vfill
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Dictionary Indexing}

\vfill
{\Large
What would happen if the proxy changed after storing a key?
}
\vfill
{\Large
Hashability requires immutability}
\vfill
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Dictionary Indexing}

\vfill
{\Large

Key lookup is very efficient

\vfill
Same average time regardless of size
}

\vfill
also... Python name look-ups are implemented with dict:

 --- its highly optimized
\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{Dictionary Indexing}

\vfill
{\Large
{\center 

key to value

lookup is one way

}}
\vfill
{\Large
{\center 

value to key

requires visiting the whole dict

}}

\vfill
{\Large
if you need to check dict values often, create another dict or set (up to you to keep them in sync)

}
\vfill
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Dictionary Ordering (not)}

\vfill
{\Large
dictionaries have no defined order
}
\vfill
\begin{verbatim}
In [352]: d = {'one':1, 'two':2, 'three':3}

In [353]: d
Out[353]: {'one': 1, 'three': 3, 'two': 2}

In [354]: d.keys()
Out[354]: ['three', 'two', 'one']
\end{verbatim}
\vfill
\end{frame} 

%-------------------------------
\begin{frame}[fragile]{Dictionary Iterating}

{\Large \verb|for| iterates the keys}
\vfill
\begin{verbatim}
>>> d = {'name': 'Brian', 'score': 42}
>>> for x in d:
...   print x
...
score name
\end{verbatim}
\vfill
{note the different order...}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{dict keys and values}

\vfill
\begin{verbatim}
>>> d.keys()
['score', 'name']

>>> d.values()
[42, 'Brian']

>>> d.items()
[('score', 42), ('name', 'Brian')]
\end{verbatim}
\vfill
\end{frame}

%-------------------------------
\begin{frame}[fragile]{dict keys and values}

{\Large iterating on everything}
\vfill
\begin{verbatim}
>>> d = {'name': 'Brian', 'score': 42}
>>> for k, v in d.items():
...   print "%s: %s" % (k, v)
...
score: 42
name: Brian
\end{verbatim}
\vfill
\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{Dictionary Performance }

\begin{itemize}
  \item indexing is fast and constant time: O(1)
  \item x in s cpnstant time: O(1)
  \item visiting all is proportional to n: O(n)
  \item inserting is constant time: O(1)
  \item deleting is constant time: O(1)
\end{itemize}

\vfill
\url{ http://wiki.python.org/moin/TimeComplexity}

\end{frame} 

% ----------------------------------------------
\begin{frame}[fragile]{Dict Comprehensions}

{\Large You can do it with dicts, too:}

\begin{verbatim}
new_dict = { key:value for variable in a_sequence}
\end{verbatim}

{\Large same as for loop:}

\begin{verbatim}
new_dict = {}
for key in a_list:
    new_dict[key] = value
\end{verbatim}

\end{frame} 

% ----------------------------------------------
\begin{frame}[fragile]{Dict Comprehensions}

{\Large Example}

\begin{verbatim}
In [340]: { i: "this_%i"%i for i in range(5) }
Out[340]: {0: 'this_0', 1: 'this_1', 2: 'this_2',
           3: 'this_3', 4: 'this_4'}
\end{verbatim}

\vfill
(not as useful with the dict() constructor...)
\end{frame} 

% ----------------------------------------------
\begin{frame}[fragile]{Switch ?}

{\Large How do you spell switch/case in Python?}

\vfill
{\Large Put the values to switch on in the keys:}

\vfill
{\Large Functions to call in values:}

\vfill
demo: sample code (\verb|switch_case.py|)
\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{ Sets }

\vfill
{\Large \verb|set| is an unordered collection of distinct values}

\vfill
{\Large Essentially a dict with only keys}

\vfill

\end{frame} 

%-------------------------------
\begin{frame}[fragile]{Set Constructors}

\vfill
\begin{verbatim}
>>> set()
set([])
>>> set([1, 2, 3])
set([1, 2, 3])
# as of 2.7
>>> {1, 2, 3}
set([1, 2, 3])
>>> s = set()
>>> s.update([1, 2, 3])
>>> s
set([1, 2, 3])
\end{verbatim}
\vfill

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{ Set Properties}

\vfill
{\Large \verb|Set| members must be hashable}

\vfill
{\Large Like dictionary keys -- and for same reason (efficient lookup)}

\vfill
{\Large No indexing (unordered) }

\vfill
\begin{verbatim}
>>> s[1]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'set' object does not support indexing
\end{verbatim}

\vfill
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{ Set Methods}

\begin{verbatim}
>> s = set([1])
>>> s.pop() # an arbitrary member
1
>>> s.pop()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'pop from an empty set'

>>> s = set([1, 2, 3])
>>> s.remove(2)
>>> s.remove(2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 2
\end{verbatim}

\vfill
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{ Set Methods}

\begin{verbatim}
s.isdisjoint(other)

s.issubset(other)

s.union(other, ...)

s.intersection(other, ...)

s.difference(other, ...)

s.symmetric_difference( other, ...)
\end{verbatim}

\vfill
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{ Frozen Set}

\vfill
{\Large Also \verb|frozenset|}

\vfill
{\Large immutable -- for use as a key in a dict\\
(or another set...)}

\vfill
\begin{verbatim}
>>> fs = frozenset((3,8,5))
>>> fs.add(9)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'frozenset' object has no attribute 'add'
\end{verbatim}

\vfill
\end{frame} 




%-------------------------------
\begin{frame}{LAB}

\vfill
{\large Some lab excercises}
\vfill

\end{frame}


%-------------------------------
\begin{frame}{Lightning Talk}

{\LARGE Lightning Talks:}

\vfill
{\large person 1}

\vfill
{\large person 2}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{Homework}

Recommended Reading:
\begin{itemize}
  \item some stuff
\end{itemize}

Do:
\begin{itemize}
    \item Some things    
\end{itemize}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Homework}

Recommended Reading:
\begin{itemize}
  \item Read Think Python: 9, 14
  \item extra: string methods: \url{http://docs.python.org/library/stdtypes.html#string-methods}
  \item extra: unicode: \url{http://www.joelonsoftware.com/articles/Unicode.html}
\end{itemize}

Do:
\begin{itemize}
    \item Six more CodingBat exercises. 
    \item LPTHW: for extra practice with the concepts -- some of:
    \begin{description}
        \item[strings:] ex5, ex6, ex7, ex8, ex9, ex10
        \item[raw\_input(), sys.argv:] ex12, ex13, ex14 (needed for files)
        \item[files:] ex15, ex16, ex17 
    \end{description}    
\end{itemize}

\end{frame}


\end{document}

 
