\documentclass{beamer}
%\usepackage[latin1]{inputenc}
\usetheme{Warsaw}
\title[Intro to Python: Week 1]{Introduction  to Python\\ Topics}
\author{Christopher Barker}
\institute{UW Continuing Education}
\date{October 15, 2013}

\usepackage{listings}
\usepackage{hyperref}

\begin{document}

% ---------------------------------------------
\begin{frame}
  \titlepage
\end{frame}

% ---------------------------------------------
\begin{frame}
\frametitle{Table of Contents}
%\tableofcontents[currentsection]
  \tableofcontents
\end{frame}


\section{Review/Questions}

% ---------------------------------------------
\begin{frame}{Review of Previous Class}

\begin{itemize}
  \item .
  \item .
  \item .
\end{itemize}

\end{frame}


% ---------------------------------------------
\begin{frame}{Lightning Talks}

\vfill
{\LARGE Lightning talks today:}

\vfill
{\Large
 

\vfill

\vfill

\vfill

}
\vfill

\end{frame}


% ---------------------------------------------
\begin{frame}{Homework review}

  \vfill
  {\Large Homework Questions? }

  \vfill
  {\Large My Solution}

  \vfill

\end{frame}

%########################
\section{First Section}

\begin{frame}[fragile]{topic}

{\Large Some Stuff}

\begin{verbatim}
sample code
\end{verbatim}


\end{frame}


\section{Lists, Tuples...}

% ---------------------------------------------
\begin{frame}[fragile]{Lists}

 {\Large Lists Literals}

\begin{verbatim}
>>> []
[]
>>> list()
[]
>>> [1, 2, 3]
[1, 2, 3]
>>> [1, 3.14, "abc"]
[1, 3.14, 'abc']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Indexing}

 {\Large Indexing just like all sequences}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food[2]
'ham'
>>> food[0]
'spam'
>>> food[42]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Mutability}

{\Large Lists are mutable}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food[1] = 'raspberries'
>>> food
['spam', 'raspberries', 'ham']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Elements}

{\Large Each element is a value, and can be in multiple lists and have multiple
names (or no name)}

\begin{verbatim}
  >>> name = 'Brian'
   >>> a = [1, 2, name]
   >>> b = [3, 4, name]
   >>> name
   'Brian'
   >>> a
   [1, 2, 'Brian']
   >>> b
   [3, 4, 'Brian']
   >>> a[2]
   'Brian'
   >>> b[2]
   'Brian'
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Methods}

{\Large \verb| .append(), .insert()|}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food.append('sushi')
>>> food
['spam', 'eggs', 'ham', 'sushi']
>>> food.insert(0, 'carrots')
>>> food
['carrots', 'spam', 'eggs', 'ham', 'sushi']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Methods}

{\large \verb| .extend()|}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food.extend(['fish', 'chips'])
>>> food
['spam', 'eggs', 'ham', 'fish', 'chips']
\end{verbatim}

{\large could be any sequence:}

\begin{verbatim}
>>>  food
>>>  ['spam', 'eggs', 'ham']
>>>  silverware = ('fork', 'knife', 'spoon') # a tuple
>>>  food.extend(silverware)
>>>  food
>>>  ['spam', 'eggs', 'ham', 'fork', 'knife', 'spoon']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Methods}

{\large \verb|pop(), remove() |}

\begin{verbatim}
In [203]: food = ['spam', 'eggs', 'ham', 'toast']
In [204]: food.pop()
Out[204]: 'toast'
In [205]: food.pop(0)
Out[205]: 'spam'
In [206]: food
Out[206]: ['eggs', 'ham']
In [207]: food.remove('ham')
In [208]: food
Out[208]: ['eggs']
\end{verbatim}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Constructor}

{\large \verb|list()| accepts any sequence and returns a list of that sequence}
\begin{verbatim}
>>> word = 'Python '
>>> chars = []
>>> for char in word:
...   chars.append(char)
>>> chars
['P', 'y', 't', 'h', 'o', 'n', ' ']
>>> list(word)
['P', 'y', 't', 'h', 'o', 'n', ' ']
\end{verbatim}
\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{String to List to String}

{\large If you need to change individual letters... you can do this,
but usually \verb|somestring.replace()| will be enough }

\begin{verbatim}
In [216]: name = 'Chris'
In [217]: lname = list(name)
In [218]: lname[0:2] = 'K'
In [219]: name = ''.join(lname)
In [220]: name
Out[220]: 'Kris'
\end{verbatim}

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{Building up strings in a list}

\begin{verbatim}
In [221]: msg = []

In [222]: msg.append('The first line of a message')

In [223]: msg.append('The second line of a message')

In [224]: msg.append('And one more line')

In [225]: print '\n'.join(msg)
The first line of a message
The second line of a message
And one more line
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Slicing}

{\large Slicing makes a copy}

\begin{verbatim}
In [227]: food = ['spam', 'eggs', 'ham', 'sushi']

In [228]: some_food = food[1:3]

In [229]: some_food[1] = 'bacon'

In [230]: food
Out[230]: ['spam', 'eggs', 'ham', 'sushi']

In [231]: some_food
Out[231]: ['eggs', 'bacon']
\end{verbatim}

\end{frame}


% ---------------------------------------------
\begin{frame}[fragile]{List Slicing}

{\large Easy way to copy a whole list}

\begin{verbatim}
In [232]: food
Out[232]: ['spam', 'eggs', 'ham', 'sushi']

In [233]: food2 = food[:]

In [234]: food is food2
Out[234]: False

\end{verbatim}

{\Large but the copy is ``shallow''}: \
\url{http://docs.python.org/library/copy.html}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Slicing}

{\Large ``Shallow'' copy}

\begin{verbatim}
In [249]: food = ['spam', ['eggs', 'ham']]
In [251]: food_copy = food[:]
In [252]: food[1].pop()
Out[252]: 'ham'
In [253]: food
Out[253]: ['spam', ['eggs']]
In [256]: food.pop(0)
Out[256]: 'spam'
In [257]: food
Out[257]: [['eggs']]
In [258]: food_copy
Out[258]: ['spam', ['eggs']]
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Name Binding}

{\Large Assigning to a name does not copy:}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> food_again = food
>>> food_copy = food[:]
>>> food.remove('sushi')
>>> food
['spam', 'eggs', 'ham']
>>> food_again
['spam', 'eggs', 'ham']
>>> food_copy
['spam', 'eggs', 'ham', 'sushi']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Iterating}

{\Large Iterating over a list}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> for x in food:
...   print x
...
spam
eggs
ham
sushi
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Processing Lists}

{\Large A common pattern}

\begin{verbatim}
filtered = []
for x in somelist:
    if should_be_included(x):
        filtered.append(x)
del(somelist)  # maybe
\end{verbatim}

{\Large you don't want to be deleting items from the list while iterating...}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Mutating Lists}

{\Large if you're going to change the list, iterate over a copy for safety }

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> for x in food[:]:
   ...   # change the list somehow
   ...
\end{verbatim}

{\Large insidious bugs otherwise}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{operators vs methods}

{\large What's the difference?}

\begin{verbatim}
   >>> food = ['spam', 'eggs', 'ham']
   >>> more = ['fish', 'chips']
   >>> food = food + more
   >>> food
   ['spam', 'eggs', 'ham', 'fish', 'chips']

   >>> food = ['spam', 'eggs', 'ham']
   >>> more = ['fish', 'chips']
   >>> food.extend(more)
   >>> food
   ['spam', 'eggs', 'ham', 'fish', 'chips']
\end{verbatim}
(the operator makes a new list...)

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{in}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> 'eggs' in food
True
>>> 'chicken feet' in food
False
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{reverse()}


\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food.reverse()
>>> food
['ham', 'eggs', 'spam']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{sort()}

\vfill
\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> food.sort()
>>> food
['eggs', 'ham', 'spam', 'sushi']
\end{verbatim}

\vfill
{\Large note:}

\vfill
\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> result = food.sort()
>>> print result
None
\end{verbatim}

\vfill
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Sorting}

{\large How should this sort?}

\begin{verbatim}
>>> s
[[2, 'a'], [1, 'b'], [1, 'c'], [1, 'a'], [2, 'c']]
\end{verbatim}

\pause

\begin{verbatim}
>>> s.sort()
>>> s
[[1, 'a'], [1, 'b'], [1, 'c'], [2, 'a'], [2, 'c']]
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Sorting}

{\large You can specify your own compare function:}

\begin{verbatim}
In [279]: s = [[2, 'a'], [1, 'b'], [1, 'c'], [1, 'a'], [2, 'c']]
In [281]: def comp(s1,s2):
   .....:     if s1[1] > s2[1]: return 1
   .....:     elif s1[1]<s2[1]: return -1
   .....:     else:
   .....:         if s1[0] > s2[0]: return 1
   .....:         elif s1[0] < s2[0]: return -1
   .....:     return 0
In [282]: s.sort(comp)
In [283]: s
Out[283]: [[1, 'a'], [2, 'a'], [1, 'b'], [1, 'c'], [2, 'c']]
\end{verbatim}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Sorting}

{\Large
Mixed types can be sorted.
}
\vfill
{\center \Large

``objects of different types always compare unequal, and are ordered
consistently but arbitrarily.''

}

\vfill
\url{http://docs.python.org/reference/expressions.html#not-in}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Searching}

{\Large Finding or Counting items}

\begin{verbatim}
In [288]: l = [3,1,7,5,4,3]

In [289]: l.index(5)
Out[289]: 3

In [290]: l.count(3)
Out[290]: 2
\end{verbatim}

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{List Performance }

\begin{itemize}
  \item indexing is fast and constant time: O(1)
  \item x in s proportional to n: O(n)
  \item visiting all is proportional to n: O(n)
  \item operating on the end of list is fast and constant time: O(1) \\
     append(), pop()
  \item operating on the front (or middle) of the list depends on n: O(n)\\
     pop(0), insert(0, v) \\
     But, reversing is fast. Also, collections.deque
\end{itemize}

\url{ http://wiki.python.org/moin/TimeComplexity}

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{Lists vs. Tuples}

\vfill
{\Large List or Tuples}

\vfill
{\Large
If it needs to mutable: list

\vfill
If it needs to be immutable: tuple\\
}
\hspace{0.2in}{\large (dict key, safety when passing to a function) }

\vfill
{\Large Otherwise ... taste and convention}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List vs Tuple}

\vfill
{\LARGE Convention:}

\vfill
{\Large Lists are Collections (homogeneous):\\[0.1in]
-- contain values of the same type \\ 
-- simplifies iterating, sorting, etc
}

\vfill
{\Large tuples are mixed types:\\[0.1in]
-- Group multiple values into one logical thing
-- Kind of like simple C structs.
}
\vfill

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List vs Tuple}

{\Large
\begin{itemize}
  \item Do the same operation to each element?
  \item Small collection of values which make a single logical item?
  \item To document that these values won't change?
  \item Build it iteratively?
  \item Transform, filter, etc?
\end{itemize}
}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List vs Tuple}

{\Large
\begin{itemize}
  \item Do the same operation to each element? {\bf list}
  \item Small collection of values which make a single logical item? {\bf tuple}
  \item To document that these values won't change? {\bf tuple}
  \item Build it iteratively? {\bf list}
  \item Transform, filter, etc? {\bf list}
\end{itemize}
}

\end{frame} 

\begin{frame}[fragile]{List Docs}

\vfill
{\Large The list docs:}

\vfill
\url{http://docs.python.org/library/stdtypes.html#mutable-sequence-types}

\vfill
(actually any mutable sequence....)

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{tuples and commas..}

{\Large  Tuples don't NEED parentheses... }

\begin{verbatim}
In [161]: t = (1,2,3)
In [162]: t
Out[162]: (1, 2, 3)

In [163]: t = 1,2,3
In [164]: t
Out[164]: (1, 2, 3)

In [165]: type(t)
Out[165]: tuple
\end{verbatim}

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{tuples and commas..}

{\Large  Tuples do need commas... }

\begin{verbatim}
In [156]: t = ( 3 )

In [157]: type(t)
Out[157]: int

In [158]: t = (3,)
In [159]: t
Out[159]: (3,)

In [160]: type(t)
Out[160]: tuple
\end{verbatim}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{LAB}

\vfill
{\LARGE List Lab}

\vfill
\verb|week-03/code/list_lab.rst|

\vfill

\end{frame}



%-------------------------------
\begin{frame}{LAB}

\vfill
{\large Some lab excercises}
\vfill

\end{frame}


%-------------------------------
\begin{frame}{Lightning Talk}

{\LARGE Lightning Talks:}

\vfill
{\large person 1}

\vfill
{\large person 2}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{Homework}

Recommended Reading:
\begin{itemize}
  \item some stuff
\end{itemize}

Do:
\begin{itemize}
    \item Some things    
\end{itemize}

\end{frame}


\end{document}

 
